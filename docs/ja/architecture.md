# アーキテクチャ

このドキュメントでは、Figramの全体的なアーキテクチャについて説明します。

## 概要

FigramはFigJam向けのYAML駆動アーキテクチャ図ツールです。明確な責務分離を持つ3パッケージのモノレポ構成を採用しています。

```
┌─────────────┐     YAML      ┌─────────────┐
│  エディタ    │ ───────────▶  │    CLI      │
│  (VSCode)   │               │  (Node.js)  │
└─────────────┘               └──────┬──────┘
                                     │
                              parse/validate
                              normalize/diff
                                     │
                                     ▼
                              ┌─────────────┐
                              │  WebSocket  │
                              │   サーバー   │
                              └──────┬──────┘
                                     │
                              patch/full msg
                                     │
                                     ▼
┌─────────────┐               ┌─────────────┐
│   FigJam    │ ◀──────────── │ プラグインUI │
│  キャンバス  │   postMessage │  (iframe)   │
└─────────────┘               └─────────────┘
```

## パッケージ構成

```
figram/
├── packages/
│   ├── core/          # DSL型、バリデーション、正規化、差分計算
│   ├── cli/           # CLIコマンド (init, build, serve)
│   └── plugin/        # FigJamプラグイン (UI + レンダラー)
├── examples/
│   └── diagram.yaml   # サンプル図
├── biome.json         # Linter/Formatter設定
└── package.json       # ワークスペースルート
```

## パッケージ

### @figram/core

**目的:** DSL処理のための依存関係なしライブラリ。

**責務:**
- DSL（YAML入力）とIR（正規化後）の型定義
- YAMLドキュメントのスキーマバリデーション
- DSLドキュメントのIR形式への正規化
- IRドキュメント間の差分計算

**主要ファイル:**
- `types.ts` - すべての型定義（DSL、IR、Patch、WebSocketプロトコル）
- `validate.ts` - 詳細なエラーメッセージ付きYAMLバリデーション
- `normalize.ts` - DSLからIRへの変換
- `diff.ts` - IR差分計算

**設計原則:**
- 最大限のポータビリティのための依存関係ゼロ
- テスト容易性のための純粋関数
- 入力（DSL）と正規化（IR）形式の明確な分離

### @figram/cli

**目的:** Node.js向けコマンドラインインターフェース。

**コマンド:**
- `init` - `diagram.yaml`テンプレートを作成
- `build` - YAMLをIR JSON形式に変換
- `serve` - ファイル監視付きWebSocketサーバーを起動

**主な機能:**
- YAMLパースに`yaml` npmパッケージを使用
- WebSocketに`ws` npmパッケージとNode.js `http`サーバーを使用
- ライブ同期のためのデバウンス付きファイル監視

**サーバーアーキテクチャ:**
```
                    ┌──────────────────────────────────┐
                    │          CLIサーバー              │
                    │                                  │
  YAMLファイル ────▶ │  ┌─────────┐    ┌────────────┐  │
                    │  │ ファイル │───▶│ validate() │  │
                    │  │ 監視     │    └─────┬──────┘  │
                    │  └─────────┘          │         │
                    │                       ▼         │
                    │               ┌────────────┐    │
                    │               │ normalize()│    │
                    │               └─────┬──────┘    │
                    │                     │           │
                    │                     ▼           │
                    │               ┌────────────┐    │
                    │               │   diff()   │    │
                    │               └─────┬──────┘    │
                    │                     │           │
                    │                     ▼           │
                    │  ┌─────────────────────────┐    │
  WebSocket ◀────── │  │  WebSocketブロードキャスト │    │
  クライアント       │  │  (patch/fullメッセージ)   │    │
                    │  └─────────────────────────┘    │
                    └──────────────────────────────────┘
```

### @figram/plugin

**目的:** 図をレンダリングするFigJamプラグイン。

**2スレッドアーキテクチャ:**

Figmaプラグインは2つの別々のスレッドで実行されます：

1. **メインスレッド**（`code.ts`）
   - Figma APIへのアクセス
   - キャンバス上にノード/エッジをレンダリング
   - ブラウザAPIは利用不可

2. **UIスレッド**（`ui.ts`）
   - iframe内で実行
   - WebSocketクライアント接続
   - すべてのブラウザAPIが利用可能

**通信:**

```
┌─────────────────────────────────────────────────────────┐
│                     FigJamプラグイン                     │
│                                                         │
│  ┌──────────────────┐         ┌────────────────────┐   │
│  │   メインスレッド   │         │    UIスレッド       │   │
│  │    (code.ts)     │         │     (ui.ts)        │   │
│  │                  │         │                    │   │
│  │  ┌────────────┐  │         │  ┌──────────────┐  │   │
│  │  │   Figma    │  │ ◀─────  │  │  WebSocket   │  │───│──▶ CLIサーバー
│  │  │    API     │  │ postMsg │  │  クライアント  │  │   │
│  │  └────────────┘  │ ─────▶  │  └──────────────┘  │   │
│  │                  │         │                    │   │
│  │  ┌────────────┐  │         │  ┌──────────────┐  │   │
│  │  │ レンダラー  │  │         │  │   UIフォーム  │  │   │
│  │  └────────────┘  │         │  │ (docId/URL)  │  │   │
│  └──────────────────┘         └────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

## データフロー

### 1. DSLからIRへのパイプライン

```
YAML文字列
    │
    ▼ yaml.parse()
    │
生オブジェクト
    │
    ▼ validate()
    │
DSLDocument（またはエラー）
    │
    ▼ normalize()
    │
IRDocument
```

### 2. 差分同期パイプライン

```
前のIR         新しいIR
    │            │
    └─────┬──────┘
          │
          ▼ diff()
          │
     PatchOp[]
          │
          ▼ broadcast()
          │
     WebSocketメッセージ
          │
          ▼ postMessage()
          │
     Figma API呼び出し
```

### 3. 全体同期フロー

```
プラグイン              CLIサーバー
  │                        │
  │  hello { docId }       │
  ├───────────────────────▶│
  │                        │
  │  full { rev, ir }      │
  │◀───────────────────────┤
  │                        │
  ▼                        │
レンダリング                │
```

### 4. 差分更新フロー

```
プラグイン              CLIサーバー               ファイル監視
  │                        │                        │
  │                        │   ファイル変更          │
  │                        │◀───────────────────────┤
  │                        │                        │
  │                        ├── validate/normalize   │
  │                        ├── diff                 │
  │                        │                        │
  │  patch { ops }         │                        │
  │◀───────────────────────┤                        │
  │                        │                        │
  ▼                        │                        │
パッチ適用                  │                        │
```

## 主要な設計判断

### なぜIR（中間表現）か？

1. **順序非依存**: DSLは配列を使用、IRはRecordを使用。これにより配列順序が差分要因から除外される。
2. **デフォルト値**: IRはすべてのオプションフィールドがデフォルト値で埋められ、下流コードが簡素化される。
3. **差分効率**: Recordベースの検索によりO(1)でノード/エッジの存在チェックが可能。

### なぜパッチ操作か？

1. **最小限の更新**: FigJamで変更された要素のみが更新される。
2. **状態の保持**: 手動調整（位置、スタイル）が上書きされない。
3. **操作順序**: 作成は親優先、削除は子優先で孤児問題を防止。

### なぜWebSocketか？

1. **リアルタイム**: ポーリングなしの即座の更新。
2. **双方向**: プラグインは必要に応じて全体状態を要求可能。
3. **効率的**: 初期同期後は差分のみを送信。

### なぜ2スレッドプラグインか？

これはFigmaの制約です：
- メインスレッドはFigma APIを持つがブラウザAPIなし
- UIスレッドはブラウザAPIを持つがFigma APIなし
- 通信は`postMessage`経由

## リビジョン管理

CLIサーバーはリビジョンカウンターを維持します：

```
currentRev = 0

ファイル変更時:
  1. YAMLをパースしてバリデーション
  2. currentIRとの差分を計算
  3. 変更がある場合:
     - prevRev = currentRev
     - currentRev++
     - patch { baseRev: prevRev, nextRev: currentRev, ops }をブロードキャスト
```

クライアントは自身のリビジョンを追跡し、更新の欠落を検出して必要に応じて全体同期を要求します。

## セキュリティ

### シークレットベース認証

`serve`コマンドはオプションのシークレット認証をサポートします：

```bash
npx figram serve diagram.yaml --secret my-secret
```

クライアントは`hello`メッセージにシークレットを含める必要があります：

```json
{ "type": "hello", "docId": "my-doc", "secret": "my-secret" }
```

### リモートアクセス

デフォルトでは、サーバーは`127.0.0.1`にバインドします。`--allow-remote`で`0.0.0.0`にバインド：

```bash
npx figram serve diagram.yaml --allow-remote
```

## テスト

テストはソースファイルと同じ場所に配置されます：

```
packages/core/
├── src/
│   ├── types.ts
│   ├── validate.ts
│   ├── validate.test.ts
│   ├── normalize.ts
│   ├── normalize.test.ts
│   ├── diff.ts
│   └── diff.test.ts
```

`bun test`で実行します。
